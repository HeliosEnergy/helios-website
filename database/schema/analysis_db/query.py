# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: query.sql
import dataclasses
import datetime
from typing import Any, AsyncIterator, Iterator, List, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from analysis_db import models


CREATE_EIA_ELECTRICITY_DATA = """-- name: create_eia_electricity_data \\:exec
INSERT INTO eia_bulk_electricity_data (
    series_id,
    name,
    units,
    frequency,
    copyright,
    source,
    iso3166,
    location,
    geography,
    start_date,
    end_date,
    last_updated,
    data
) VALUES (
    :p1,
    :p2,
    :p3,
    :p4,
    :p5,
    :p6,
    :p7,
    ST_SetSRID(ST_MakePoint(
        :p8\\:\\:float8,
        :p9\\:\\:float8
    ), 4326)\\:\\:geography,
    :p10,
    :p11,
    :p12,
    :p13,
    :p14
)
"""


@dataclasses.dataclass()
class CreateEIAElectricityDataParams:
    series_id: str
    name: str
    units: str
    frequency: Optional[str]
    copyright: Optional[str]
    source: Optional[str]
    iso3166: Optional[str]
    longitude: float
    latitude: float
    geography: Optional[str]
    start_date: Optional[datetime.datetime]
    end_date: Optional[datetime.datetime]
    last_updated: Optional[datetime.datetime]
    data: Optional[Any]


CREATE_EIA_PLANT_GENERATION = """-- name: create_eia_plant_generation \\:one
INSERT INTO eia_plant_generation (
    plant_id,
    timestamp,
    period,
    generation,
    generation_units,
    gross_generation,
    gross_generation_units,
    consumption_for_eg,
    consumption_for_eg_units,
    consumption_for_eg_btu,
    consumption_for_eg_btu_units,
    total_consumption,
    total_consumption_units,
    total_consumption_btu,
    total_consumption_btu_units,
    average_heat_content,
    average_heat_content_units,
    source_timestamp,
    metadata
) VALUES (
    :p1,
    COALESCE(:p2, CURRENT_TIMESTAMP),
    :p3,
    :p4,
    :p5,
    :p6,
    :p7,
    :p8,
    :p9,
    :p10,
    :p11,
    :p12,
    :p13,
    :p14,
    :p15,
    :p16,
    :p17,
    :p18,
    :p19
)
RETURNING id, plant_id, timestamp, period, generation, generation_units, gross_generation, gross_generation_units, consumption_for_eg, consumption_for_eg_units, consumption_for_eg_btu, consumption_for_eg_btu_units, total_consumption, total_consumption_units, total_consumption_btu, total_consumption_btu_units, average_heat_content, average_heat_content_units, source_timestamp, metadata, created_at
"""


@dataclasses.dataclass()
class CreateEIAPlantGenerationParams:
    plant_id: Optional[int]
    timestamp: Optional[Any]
    period: Optional[str]
    generation: Optional[float]
    generation_units: Optional[str]
    gross_generation: Optional[float]
    gross_generation_units: Optional[str]
    consumption_for_eg: Optional[float]
    consumption_for_eg_units: Optional[str]
    consumption_for_eg_btu: Optional[float]
    consumption_for_eg_btu_units: Optional[str]
    total_consumption: Optional[float]
    total_consumption_units: Optional[str]
    total_consumption_btu: Optional[float]
    total_consumption_btu_units: Optional[str]
    average_heat_content: Optional[float]
    average_heat_content_units: Optional[str]
    source_timestamp: Optional[datetime.datetime]
    metadata: Optional[Any]


CREATE_EIA_PLANT_STAT = """-- name: create_eia_plant_stat \\:one
INSERT INTO eia_plant_capacity (
    plant_id,
    timestamp,
    nameplate_capacity_mw,
    net_summer_capacity_mw,
    net_winter_capacity_mw,
    planned_derate_summer_cap_mw,
    planned_uprate_summer_cap_mw,
    operating_year_month,
    planned_derate_year_month,
    planned_uprate_year_month,
    planned_retirement_year_month,
    source_timestamp,
    data_period,
    metadata
) VALUES (
    :p1,
    COALESCE(:p2, CURRENT_TIMESTAMP),
    :p3,
    :p4,
    :p5,
    :p6,
    :p7,
    :p8,
    :p9,
    :p10,
    :p11,
    :p12,
    :p13,
    :p14
)
RETURNING id, plant_id, timestamp, nameplate_capacity_mw, net_summer_capacity_mw, net_winter_capacity_mw, planned_derate_summer_cap_mw, planned_uprate_summer_cap_mw, operating_year_month, planned_derate_year_month, planned_uprate_year_month, planned_retirement_year_month, source_timestamp, data_period, metadata, created_at
"""


@dataclasses.dataclass()
class CreateEIAPlantStatParams:
    plant_id: Optional[int]
    timestamp: Optional[Any]
    nameplate_capacity_mw: Optional[float]
    net_summer_capacity_mw: Optional[float]
    net_winter_capacity_mw: Optional[float]
    planned_derate_summer_cap_mw: Optional[float]
    planned_uprate_summer_cap_mw: Optional[float]
    operating_year_month: Optional[datetime.date]
    planned_derate_year_month: Optional[datetime.date]
    planned_uprate_year_month: Optional[datetime.date]
    planned_retirement_year_month: Optional[datetime.date]
    source_timestamp: Optional[datetime.datetime]
    data_period: Optional[str]
    metadata: Optional[Any]


CREATE_METRIC = """-- name: create_metric \\:one
INSERT INTO metrics (
    name,
    value,
    timestamp
) VALUES (
    :p1, :p2, :p3
) RETURNING id, name, value, timestamp
"""


DELETE_METRIC = """-- name: delete_metric \\:exec
DELETE FROM metrics
WHERE id = :p1
"""


GET_ALL_POWER_PLANTS_WITH_LATEST_STATS = """-- name: get_all_power_plants_with_latest_stats \\:many
SELECT 
    p.id, 
    p.api_plant_id, 
    p.entity_id, 
    p.name, 
    p.county, 
    p.state,
    ST_X(p.location\\:\\:geometry) AS longitude,
    ST_Y(p.location\\:\\:geometry) AS latitude,
    p.plant_code,
    p.fuel_type,
    p.prime_mover,
    p.operating_status,
    p.metadata AS plant_metadata,
    p.created_at AS plant_created_at,
    p.updated_at AS plant_updated_at,
    s.id AS stat_id,
    s.nameplate_capacity_mw,
    s.net_summer_capacity_mw,
    s.net_winter_capacity_mw,
    s.planned_derate_summer_cap_mw,
    s.planned_uprate_summer_cap_mw,
    s.operating_year_month,
    s.planned_derate_year_month,
    s.planned_uprate_year_month,
    s.planned_retirement_year_month,
    s.source_timestamp,
    s.data_period,
    s.metadata AS stat_metadata,
    s.timestamp AS stat_timestamp
FROM eia_power_plants as p
LEFT JOIN (
    SELECT DISTINCT ON (plant_id) id, plant_id, timestamp, nameplate_capacity_mw, net_summer_capacity_mw, net_winter_capacity_mw, planned_derate_summer_cap_mw, planned_uprate_summer_cap_mw, operating_year_month, planned_derate_year_month, planned_uprate_year_month, planned_retirement_year_month, source_timestamp, data_period, metadata, created_at
    FROM eia_plant_capacity
    ORDER BY plant_id, timestamp DESC
) as s ON s.plant_id = p.id
WHERE 
    (:p1\\:\\:text IS NULL OR p.fuel_type = :p1)
    AND (
        :p2\\:\\:text[] IS NULL 
        OR :p2\\:\\:text[] = '{}'\\:\\:text[] 
        OR p.state = ANY(:p2\\:\\:text[])
    )
    AND (:p3\\:\\:text IS NULL OR p.operating_status = :p3)
    AND (
        :p4\\:\\:float IS NULL 
        OR (s.nameplate_capacity_mw IS NOT NULL AND s.nameplate_capacity_mw >= :p4)
    )
    AND (
        :p5\\:\\:float IS NULL 
        OR (s.nameplate_capacity_mw IS NOT NULL AND s.nameplate_capacity_mw <= :p5)
    )
"""


@dataclasses.dataclass()
class GetAllPowerPlantsWithLatestStatsParams:
    fuel_type: Optional[str]
    states: Optional[List[str]]
    operating_status: Optional[str]
    min_capacity: Optional[float]
    max_capacity: Optional[float]


@dataclasses.dataclass()
class GetAllPowerPlantsWithLatestStatsRow:
    id: int
    api_plant_id: str
    entity_id: Optional[int]
    name: str
    county: Optional[str]
    state: Optional[str]
    longitude: Optional[Any]
    latitude: Optional[Any]
    plant_code: Optional[str]
    fuel_type: Optional[str]
    prime_mover: Optional[str]
    operating_status: Optional[str]
    plant_metadata: Optional[Any]
    plant_created_at: Optional[datetime.datetime]
    plant_updated_at: Optional[datetime.datetime]
    stat_id: int
    nameplate_capacity_mw: Optional[float]
    net_summer_capacity_mw: Optional[float]
    net_winter_capacity_mw: Optional[float]
    planned_derate_summer_cap_mw: Optional[float]
    planned_uprate_summer_cap_mw: Optional[float]
    operating_year_month: Optional[datetime.date]
    planned_derate_year_month: Optional[datetime.date]
    planned_uprate_year_month: Optional[datetime.date]
    planned_retirement_year_month: Optional[datetime.date]
    source_timestamp: Optional[datetime.datetime]
    data_period: Optional[str]
    stat_metadata: Optional[Any]
    stat_timestamp: datetime.datetime


GET_EIA_ENTITY_BY_API_ID = """-- name: get_eia_entity_by_api_id \\:one

SELECT id, api_entity_id, name, description, metadata, created_at, updated_at FROM eia_entities
WHERE api_entity_id = :p1
"""


GET_EIA_PLANT_GENERATION_BY_PLANT_ID = """-- name: get_eia_plant_generation_by_plant_id \\:many
SELECT id, plant_id, timestamp, period, generation, generation_units, gross_generation, gross_generation_units, consumption_for_eg, consumption_for_eg_units, consumption_for_eg_btu, consumption_for_eg_btu_units, total_consumption, total_consumption_units, total_consumption_btu, total_consumption_btu_units, average_heat_content, average_heat_content_units, source_timestamp, metadata, created_at FROM eia_plant_generation
WHERE plant_id = :p1
ORDER BY timestamp DESC
"""


GET_EIA_PLANT_GENERATION_IN_TIME_RANGE = """-- name: get_eia_plant_generation_in_time_range \\:many
SELECT id, plant_id, timestamp, period, generation, generation_units, gross_generation, gross_generation_units, consumption_for_eg, consumption_for_eg_units, consumption_for_eg_btu, consumption_for_eg_btu_units, total_consumption, total_consumption_units, total_consumption_btu, total_consumption_btu_units, average_heat_content, average_heat_content_units, source_timestamp, metadata, created_at FROM eia_plant_generation
WHERE plant_id = :p1
AND timestamp BETWEEN :p2 AND :p3
ORDER BY timestamp DESC
"""


GET_EIA_PLANT_STATS_BY_PLANT_ID = """-- name: get_eia_plant_stats_by_plant_id \\:many
SELECT id, plant_id, timestamp, nameplate_capacity_mw, net_summer_capacity_mw, net_winter_capacity_mw, planned_derate_summer_cap_mw, planned_uprate_summer_cap_mw, operating_year_month, planned_derate_year_month, planned_uprate_year_month, planned_retirement_year_month, source_timestamp, data_period, metadata, created_at FROM eia_plant_capacity
WHERE plant_id = :p1
ORDER BY timestamp DESC
"""


GET_EIA_PLANT_STATS_IN_TIME_RANGE = """-- name: get_eia_plant_stats_in_time_range \\:many
SELECT id, plant_id, timestamp, nameplate_capacity_mw, net_summer_capacity_mw, net_winter_capacity_mw, planned_derate_summer_cap_mw, planned_uprate_summer_cap_mw, operating_year_month, planned_derate_year_month, planned_uprate_year_month, planned_retirement_year_month, source_timestamp, data_period, metadata, created_at FROM eia_plant_capacity
WHERE plant_id = :p1
AND timestamp BETWEEN :p2 AND :p3
ORDER BY timestamp DESC
"""


GET_EIA_POWER_PLANT_BY_API_ID = """-- name: get_eia_power_plant_by_api_id \\:one
SELECT id, api_plant_id, entity_id, name, county, state, location, plant_code, fuel_type, prime_mover, operating_status, metadata, created_at, updated_at FROM eia_power_plants
WHERE api_plant_id = :p1
"""


GET_EIA_POWER_PLANTS_FOR_ENTITY = """-- name: get_eia_power_plants_for_entity \\:many
SELECT id, api_plant_id, entity_id, name, county, state, location, plant_code, fuel_type, prime_mover, operating_status, metadata, created_at, updated_at FROM eia_power_plants
WHERE entity_id = :p1
"""


GET_LATEST_EIA_PLANT_GENERATION = """-- name: get_latest_eia_plant_generation \\:one
SELECT id, plant_id, timestamp, period, generation, generation_units, gross_generation, gross_generation_units, consumption_for_eg, consumption_for_eg_units, consumption_for_eg_btu, consumption_for_eg_btu_units, total_consumption, total_consumption_units, total_consumption_btu, total_consumption_btu_units, average_heat_content, average_heat_content_units, source_timestamp, metadata, created_at FROM eia_plant_generation
WHERE plant_id = :p1
ORDER BY timestamp DESC
LIMIT 1
"""


GET_LATEST_EIA_PLANT_STAT = """-- name: get_latest_eia_plant_stat \\:one
SELECT id, plant_id, timestamp, nameplate_capacity_mw, net_summer_capacity_mw, net_winter_capacity_mw, planned_derate_summer_cap_mw, planned_uprate_summer_cap_mw, operating_year_month, planned_derate_year_month, planned_uprate_year_month, planned_retirement_year_month, source_timestamp, data_period, metadata, created_at FROM eia_plant_capacity
WHERE plant_id = :p1
ORDER BY timestamp DESC
LIMIT 1
"""


GET_METRIC = """-- name: get_metric \\:one
SELECT id, name, value, timestamp FROM metrics
WHERE id = :p1
"""


GET_METRICS_BY_NAME = """-- name: get_metrics_by_name \\:many
SELECT id, name, value, timestamp FROM metrics
WHERE name = :p1
ORDER BY timestamp DESC
"""


GET_METRICS_BY_TIME_RANGE = """-- name: get_metrics_by_time_range \\:many
SELECT id, name, value, timestamp FROM metrics
WHERE timestamp BETWEEN :p1 AND :p2
ORDER BY timestamp DESC
"""


LIST_METRICS = """-- name: list_metrics \\:many
SELECT id, name, value, timestamp FROM metrics
ORDER BY timestamp DESC
"""


UPDATE_METRIC = """-- name: update_metric \\:one
UPDATE metrics
SET name = :p2,
    value = :p3,
    timestamp = :p4
WHERE id = :p1
RETURNING id, name, value, timestamp
"""


UPSERT_EIA_ENTITY = """-- name: upsert_eia_entity \\:one
INSERT INTO eia_entities (
    api_entity_id,
    name,
    description,
    metadata
) VALUES (
    :p1,
    :p2,
    :p3,
    :p4
)
ON CONFLICT (api_entity_id) 
DO UPDATE SET
    name = EXCLUDED.name,
    description = EXCLUDED.description,
    metadata = EXCLUDED.metadata,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, api_entity_id, name, description, metadata, created_at, updated_at
"""


UPSERT_EIA_POWER_PLANT = """-- name: upsert_eia_power_plant \\:one
INSERT INTO eia_power_plants (
    api_plant_id,
    entity_id,
    name,
    county,
    state,
    location,
    plant_code,
    fuel_type,
    prime_mover,
    operating_status,
    metadata
) VALUES (
    :p1,
    :p2,
    :p3,
    :p4,
    :p5,
    ST_SetSRID(ST_MakePoint(
        :p6\\:\\:float8,
        :p7\\:\\:float8
    ), 4326)\\:\\:geography,
    :p8,
    :p9,
    :p10,
    :p11,
    :p12
)
ON CONFLICT (api_plant_id) 
DO UPDATE SET
    entity_id = EXCLUDED.entity_id,
    name = EXCLUDED.name,
    county = EXCLUDED.county,
    state = EXCLUDED.state,
    location = EXCLUDED.location,
    plant_code = EXCLUDED.plant_code,
    fuel_type = EXCLUDED.fuel_type,
    prime_mover = EXCLUDED.prime_mover,
    operating_status = EXCLUDED.operating_status,
    metadata = EXCLUDED.metadata,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, api_plant_id, entity_id, name, county, state, location, plant_code, fuel_type, prime_mover, operating_status, metadata, created_at, updated_at
"""


@dataclasses.dataclass()
class UpsertEIAPowerPlantParams:
    api_plant_id: str
    entity_id: Optional[int]
    name: str
    county: Optional[str]
    state: Optional[str]
    longitude: float
    latitude: float
    plant_code: Optional[str]
    fuel_type: Optional[str]
    prime_mover: Optional[str]
    operating_status: Optional[str]
    metadata: Optional[Any]


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def create_eia_electricity_data(self, arg: CreateEIAElectricityDataParams) -> None:
        self._conn.execute(sqlalchemy.text(CREATE_EIA_ELECTRICITY_DATA), {
            "p1": arg.series_id,
            "p2": arg.name,
            "p3": arg.units,
            "p4": arg.frequency,
            "p5": arg.copyright,
            "p6": arg.source,
            "p7": arg.iso3166,
            "p8": arg.longitude,
            "p9": arg.latitude,
            "p10": arg.geography,
            "p11": arg.start_date,
            "p12": arg.end_date,
            "p13": arg.last_updated,
            "p14": arg.data,
        })

    def create_eia_plant_generation(self, arg: CreateEIAPlantGenerationParams) -> Optional[models.EiaPlantGeneration]:
        row = self._conn.execute(sqlalchemy.text(CREATE_EIA_PLANT_GENERATION), {
            "p1": arg.plant_id,
            "p2": arg.timestamp,
            "p3": arg.period,
            "p4": arg.generation,
            "p5": arg.generation_units,
            "p6": arg.gross_generation,
            "p7": arg.gross_generation_units,
            "p8": arg.consumption_for_eg,
            "p9": arg.consumption_for_eg_units,
            "p10": arg.consumption_for_eg_btu,
            "p11": arg.consumption_for_eg_btu_units,
            "p12": arg.total_consumption,
            "p13": arg.total_consumption_units,
            "p14": arg.total_consumption_btu,
            "p15": arg.total_consumption_btu_units,
            "p16": arg.average_heat_content,
            "p17": arg.average_heat_content_units,
            "p18": arg.source_timestamp,
            "p19": arg.metadata,
        }).first()
        if row is None:
            return None
        return models.EiaPlantGeneration(
            id=row[0],
            plant_id=row[1],
            timestamp=row[2],
            period=row[3],
            generation=row[4],
            generation_units=row[5],
            gross_generation=row[6],
            gross_generation_units=row[7],
            consumption_for_eg=row[8],
            consumption_for_eg_units=row[9],
            consumption_for_eg_btu=row[10],
            consumption_for_eg_btu_units=row[11],
            total_consumption=row[12],
            total_consumption_units=row[13],
            total_consumption_btu=row[14],
            total_consumption_btu_units=row[15],
            average_heat_content=row[16],
            average_heat_content_units=row[17],
            source_timestamp=row[18],
            metadata=row[19],
            created_at=row[20],
        )

    def create_eia_plant_stat(self, arg: CreateEIAPlantStatParams) -> Optional[models.EiaPlantCapacity]:
        row = self._conn.execute(sqlalchemy.text(CREATE_EIA_PLANT_STAT), {
            "p1": arg.plant_id,
            "p2": arg.timestamp,
            "p3": arg.nameplate_capacity_mw,
            "p4": arg.net_summer_capacity_mw,
            "p5": arg.net_winter_capacity_mw,
            "p6": arg.planned_derate_summer_cap_mw,
            "p7": arg.planned_uprate_summer_cap_mw,
            "p8": arg.operating_year_month,
            "p9": arg.planned_derate_year_month,
            "p10": arg.planned_uprate_year_month,
            "p11": arg.planned_retirement_year_month,
            "p12": arg.source_timestamp,
            "p13": arg.data_period,
            "p14": arg.metadata,
        }).first()
        if row is None:
            return None
        return models.EiaPlantCapacity(
            id=row[0],
            plant_id=row[1],
            timestamp=row[2],
            nameplate_capacity_mw=row[3],
            net_summer_capacity_mw=row[4],
            net_winter_capacity_mw=row[5],
            planned_derate_summer_cap_mw=row[6],
            planned_uprate_summer_cap_mw=row[7],
            operating_year_month=row[8],
            planned_derate_year_month=row[9],
            planned_uprate_year_month=row[10],
            planned_retirement_year_month=row[11],
            source_timestamp=row[12],
            data_period=row[13],
            metadata=row[14],
            created_at=row[15],
        )

    def create_metric(self, *, name: str, value: float, timestamp: Optional[datetime.datetime]) -> Optional[models.Metric]:
        row = self._conn.execute(sqlalchemy.text(CREATE_METRIC), {"p1": name, "p2": value, "p3": timestamp}).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )

    def delete_metric(self, *, id: int) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_METRIC), {"p1": id})

    def get_all_power_plants_with_latest_stats(self, arg: GetAllPowerPlantsWithLatestStatsParams) -> Iterator[GetAllPowerPlantsWithLatestStatsRow]:
        result = self._conn.execute(sqlalchemy.text(GET_ALL_POWER_PLANTS_WITH_LATEST_STATS), {
            "p1": arg.fuel_type,
            "p2": arg.states,
            "p3": arg.operating_status,
            "p4": arg.min_capacity,
            "p5": arg.max_capacity,
        })
        for row in result:
            yield GetAllPowerPlantsWithLatestStatsRow(
                id=row[0],
                api_plant_id=row[1],
                entity_id=row[2],
                name=row[3],
                county=row[4],
                state=row[5],
                longitude=row[6],
                latitude=row[7],
                plant_code=row[8],
                fuel_type=row[9],
                prime_mover=row[10],
                operating_status=row[11],
                plant_metadata=row[12],
                plant_created_at=row[13],
                plant_updated_at=row[14],
                stat_id=row[15],
                nameplate_capacity_mw=row[16],
                net_summer_capacity_mw=row[17],
                net_winter_capacity_mw=row[18],
                planned_derate_summer_cap_mw=row[19],
                planned_uprate_summer_cap_mw=row[20],
                operating_year_month=row[21],
                planned_derate_year_month=row[22],
                planned_uprate_year_month=row[23],
                planned_retirement_year_month=row[24],
                source_timestamp=row[25],
                data_period=row[26],
                stat_metadata=row[27],
                stat_timestamp=row[28],
            )

    def get_eia_entity_by_api_id(self, *, api_entity_id: str) -> Optional[models.EiaEntity]:
        row = self._conn.execute(sqlalchemy.text(GET_EIA_ENTITY_BY_API_ID), {"p1": api_entity_id}).first()
        if row is None:
            return None
        return models.EiaEntity(
            id=row[0],
            api_entity_id=row[1],
            name=row[2],
            description=row[3],
            metadata=row[4],
            created_at=row[5],
            updated_at=row[6],
        )

    def get_eia_plant_generation_by_plant_id(self, *, plant_id: Optional[int]) -> Iterator[models.EiaPlantGeneration]:
        result = self._conn.execute(sqlalchemy.text(GET_EIA_PLANT_GENERATION_BY_PLANT_ID), {"p1": plant_id})
        for row in result:
            yield models.EiaPlantGeneration(
                id=row[0],
                plant_id=row[1],
                timestamp=row[2],
                period=row[3],
                generation=row[4],
                generation_units=row[5],
                gross_generation=row[6],
                gross_generation_units=row[7],
                consumption_for_eg=row[8],
                consumption_for_eg_units=row[9],
                consumption_for_eg_btu=row[10],
                consumption_for_eg_btu_units=row[11],
                total_consumption=row[12],
                total_consumption_units=row[13],
                total_consumption_btu=row[14],
                total_consumption_btu_units=row[15],
                average_heat_content=row[16],
                average_heat_content_units=row[17],
                source_timestamp=row[18],
                metadata=row[19],
                created_at=row[20],
            )

    def get_eia_plant_generation_in_time_range(self, *, plant_id: Optional[int], start_timestamp: datetime.datetime, end_timestamp: datetime.datetime) -> Iterator[models.EiaPlantGeneration]:
        result = self._conn.execute(sqlalchemy.text(GET_EIA_PLANT_GENERATION_IN_TIME_RANGE), {"p1": plant_id, "p2": start_timestamp, "p3": end_timestamp})
        for row in result:
            yield models.EiaPlantGeneration(
                id=row[0],
                plant_id=row[1],
                timestamp=row[2],
                period=row[3],
                generation=row[4],
                generation_units=row[5],
                gross_generation=row[6],
                gross_generation_units=row[7],
                consumption_for_eg=row[8],
                consumption_for_eg_units=row[9],
                consumption_for_eg_btu=row[10],
                consumption_for_eg_btu_units=row[11],
                total_consumption=row[12],
                total_consumption_units=row[13],
                total_consumption_btu=row[14],
                total_consumption_btu_units=row[15],
                average_heat_content=row[16],
                average_heat_content_units=row[17],
                source_timestamp=row[18],
                metadata=row[19],
                created_at=row[20],
            )

    def get_eia_plant_stats_by_plant_id(self, *, plant_id: Optional[int]) -> Iterator[models.EiaPlantCapacity]:
        result = self._conn.execute(sqlalchemy.text(GET_EIA_PLANT_STATS_BY_PLANT_ID), {"p1": plant_id})
        for row in result:
            yield models.EiaPlantCapacity(
                id=row[0],
                plant_id=row[1],
                timestamp=row[2],
                nameplate_capacity_mw=row[3],
                net_summer_capacity_mw=row[4],
                net_winter_capacity_mw=row[5],
                planned_derate_summer_cap_mw=row[6],
                planned_uprate_summer_cap_mw=row[7],
                operating_year_month=row[8],
                planned_derate_year_month=row[9],
                planned_uprate_year_month=row[10],
                planned_retirement_year_month=row[11],
                source_timestamp=row[12],
                data_period=row[13],
                metadata=row[14],
                created_at=row[15],
            )

    def get_eia_plant_stats_in_time_range(self, *, plant_id: Optional[int], start_timestamp: datetime.datetime, end_timestamp: datetime.datetime) -> Iterator[models.EiaPlantCapacity]:
        result = self._conn.execute(sqlalchemy.text(GET_EIA_PLANT_STATS_IN_TIME_RANGE), {"p1": plant_id, "p2": start_timestamp, "p3": end_timestamp})
        for row in result:
            yield models.EiaPlantCapacity(
                id=row[0],
                plant_id=row[1],
                timestamp=row[2],
                nameplate_capacity_mw=row[3],
                net_summer_capacity_mw=row[4],
                net_winter_capacity_mw=row[5],
                planned_derate_summer_cap_mw=row[6],
                planned_uprate_summer_cap_mw=row[7],
                operating_year_month=row[8],
                planned_derate_year_month=row[9],
                planned_uprate_year_month=row[10],
                planned_retirement_year_month=row[11],
                source_timestamp=row[12],
                data_period=row[13],
                metadata=row[14],
                created_at=row[15],
            )

    def get_eia_power_plant_by_api_id(self, *, api_plant_id: str) -> Optional[models.EiaPowerPlant]:
        row = self._conn.execute(sqlalchemy.text(GET_EIA_POWER_PLANT_BY_API_ID), {"p1": api_plant_id}).first()
        if row is None:
            return None
        return models.EiaPowerPlant(
            id=row[0],
            api_plant_id=row[1],
            entity_id=row[2],
            name=row[3],
            county=row[4],
            state=row[5],
            location=row[6],
            plant_code=row[7],
            fuel_type=row[8],
            prime_mover=row[9],
            operating_status=row[10],
            metadata=row[11],
            created_at=row[12],
            updated_at=row[13],
        )

    def get_eia_power_plants_for_entity(self, *, entity_id: Optional[int]) -> Iterator[models.EiaPowerPlant]:
        result = self._conn.execute(sqlalchemy.text(GET_EIA_POWER_PLANTS_FOR_ENTITY), {"p1": entity_id})
        for row in result:
            yield models.EiaPowerPlant(
                id=row[0],
                api_plant_id=row[1],
                entity_id=row[2],
                name=row[3],
                county=row[4],
                state=row[5],
                location=row[6],
                plant_code=row[7],
                fuel_type=row[8],
                prime_mover=row[9],
                operating_status=row[10],
                metadata=row[11],
                created_at=row[12],
                updated_at=row[13],
            )

    def get_latest_eia_plant_generation(self, *, plant_id: Optional[int]) -> Optional[models.EiaPlantGeneration]:
        row = self._conn.execute(sqlalchemy.text(GET_LATEST_EIA_PLANT_GENERATION), {"p1": plant_id}).first()
        if row is None:
            return None
        return models.EiaPlantGeneration(
            id=row[0],
            plant_id=row[1],
            timestamp=row[2],
            period=row[3],
            generation=row[4],
            generation_units=row[5],
            gross_generation=row[6],
            gross_generation_units=row[7],
            consumption_for_eg=row[8],
            consumption_for_eg_units=row[9],
            consumption_for_eg_btu=row[10],
            consumption_for_eg_btu_units=row[11],
            total_consumption=row[12],
            total_consumption_units=row[13],
            total_consumption_btu=row[14],
            total_consumption_btu_units=row[15],
            average_heat_content=row[16],
            average_heat_content_units=row[17],
            source_timestamp=row[18],
            metadata=row[19],
            created_at=row[20],
        )

    def get_latest_eia_plant_stat(self, *, plant_id: Optional[int]) -> Optional[models.EiaPlantCapacity]:
        row = self._conn.execute(sqlalchemy.text(GET_LATEST_EIA_PLANT_STAT), {"p1": plant_id}).first()
        if row is None:
            return None
        return models.EiaPlantCapacity(
            id=row[0],
            plant_id=row[1],
            timestamp=row[2],
            nameplate_capacity_mw=row[3],
            net_summer_capacity_mw=row[4],
            net_winter_capacity_mw=row[5],
            planned_derate_summer_cap_mw=row[6],
            planned_uprate_summer_cap_mw=row[7],
            operating_year_month=row[8],
            planned_derate_year_month=row[9],
            planned_uprate_year_month=row[10],
            planned_retirement_year_month=row[11],
            source_timestamp=row[12],
            data_period=row[13],
            metadata=row[14],
            created_at=row[15],
        )

    def get_metric(self, *, id: int) -> Optional[models.Metric]:
        row = self._conn.execute(sqlalchemy.text(GET_METRIC), {"p1": id}).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )

    def get_metrics_by_name(self, *, name: str) -> Iterator[models.Metric]:
        result = self._conn.execute(sqlalchemy.text(GET_METRICS_BY_NAME), {"p1": name})
        for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    def get_metrics_by_time_range(self, *, start_timestamp: Optional[datetime.datetime], end_timestamp: Optional[datetime.datetime]) -> Iterator[models.Metric]:
        result = self._conn.execute(sqlalchemy.text(GET_METRICS_BY_TIME_RANGE), {"p1": start_timestamp, "p2": end_timestamp})
        for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    def list_metrics(self) -> Iterator[models.Metric]:
        result = self._conn.execute(sqlalchemy.text(LIST_METRICS))
        for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    def update_metric(self, *, id: int, name: str, value: float, timestamp: Optional[datetime.datetime]) -> Optional[models.Metric]:
        row = self._conn.execute(sqlalchemy.text(UPDATE_METRIC), {
            "p1": id,
            "p2": name,
            "p3": value,
            "p4": timestamp,
        }).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )

    def upsert_eia_entity(self, *, api_entity_id: str, name: str, description: Optional[str], metadata: Optional[Any]) -> Optional[models.EiaEntity]:
        row = self._conn.execute(sqlalchemy.text(UPSERT_EIA_ENTITY), {
            "p1": api_entity_id,
            "p2": name,
            "p3": description,
            "p4": metadata,
        }).first()
        if row is None:
            return None
        return models.EiaEntity(
            id=row[0],
            api_entity_id=row[1],
            name=row[2],
            description=row[3],
            metadata=row[4],
            created_at=row[5],
            updated_at=row[6],
        )

    def upsert_eia_power_plant(self, arg: UpsertEIAPowerPlantParams) -> Optional[models.EiaPowerPlant]:
        row = self._conn.execute(sqlalchemy.text(UPSERT_EIA_POWER_PLANT), {
            "p1": arg.api_plant_id,
            "p2": arg.entity_id,
            "p3": arg.name,
            "p4": arg.county,
            "p5": arg.state,
            "p6": arg.longitude,
            "p7": arg.latitude,
            "p8": arg.plant_code,
            "p9": arg.fuel_type,
            "p10": arg.prime_mover,
            "p11": arg.operating_status,
            "p12": arg.metadata,
        }).first()
        if row is None:
            return None
        return models.EiaPowerPlant(
            id=row[0],
            api_plant_id=row[1],
            entity_id=row[2],
            name=row[3],
            county=row[4],
            state=row[5],
            location=row[6],
            plant_code=row[7],
            fuel_type=row[8],
            prime_mover=row[9],
            operating_status=row[10],
            metadata=row[11],
            created_at=row[12],
            updated_at=row[13],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_eia_electricity_data(self, arg: CreateEIAElectricityDataParams) -> None:
        await self._conn.execute(sqlalchemy.text(CREATE_EIA_ELECTRICITY_DATA), {
            "p1": arg.series_id,
            "p2": arg.name,
            "p3": arg.units,
            "p4": arg.frequency,
            "p5": arg.copyright,
            "p6": arg.source,
            "p7": arg.iso3166,
            "p8": arg.longitude,
            "p9": arg.latitude,
            "p10": arg.geography,
            "p11": arg.start_date,
            "p12": arg.end_date,
            "p13": arg.last_updated,
            "p14": arg.data,
        })

    async def create_eia_plant_generation(self, arg: CreateEIAPlantGenerationParams) -> Optional[models.EiaPlantGeneration]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_EIA_PLANT_GENERATION), {
            "p1": arg.plant_id,
            "p2": arg.timestamp,
            "p3": arg.period,
            "p4": arg.generation,
            "p5": arg.generation_units,
            "p6": arg.gross_generation,
            "p7": arg.gross_generation_units,
            "p8": arg.consumption_for_eg,
            "p9": arg.consumption_for_eg_units,
            "p10": arg.consumption_for_eg_btu,
            "p11": arg.consumption_for_eg_btu_units,
            "p12": arg.total_consumption,
            "p13": arg.total_consumption_units,
            "p14": arg.total_consumption_btu,
            "p15": arg.total_consumption_btu_units,
            "p16": arg.average_heat_content,
            "p17": arg.average_heat_content_units,
            "p18": arg.source_timestamp,
            "p19": arg.metadata,
        })).first()
        if row is None:
            return None
        return models.EiaPlantGeneration(
            id=row[0],
            plant_id=row[1],
            timestamp=row[2],
            period=row[3],
            generation=row[4],
            generation_units=row[5],
            gross_generation=row[6],
            gross_generation_units=row[7],
            consumption_for_eg=row[8],
            consumption_for_eg_units=row[9],
            consumption_for_eg_btu=row[10],
            consumption_for_eg_btu_units=row[11],
            total_consumption=row[12],
            total_consumption_units=row[13],
            total_consumption_btu=row[14],
            total_consumption_btu_units=row[15],
            average_heat_content=row[16],
            average_heat_content_units=row[17],
            source_timestamp=row[18],
            metadata=row[19],
            created_at=row[20],
        )

    async def create_eia_plant_stat(self, arg: CreateEIAPlantStatParams) -> Optional[models.EiaPlantCapacity]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_EIA_PLANT_STAT), {
            "p1": arg.plant_id,
            "p2": arg.timestamp,
            "p3": arg.nameplate_capacity_mw,
            "p4": arg.net_summer_capacity_mw,
            "p5": arg.net_winter_capacity_mw,
            "p6": arg.planned_derate_summer_cap_mw,
            "p7": arg.planned_uprate_summer_cap_mw,
            "p8": arg.operating_year_month,
            "p9": arg.planned_derate_year_month,
            "p10": arg.planned_uprate_year_month,
            "p11": arg.planned_retirement_year_month,
            "p12": arg.source_timestamp,
            "p13": arg.data_period,
            "p14": arg.metadata,
        })).first()
        if row is None:
            return None
        return models.EiaPlantCapacity(
            id=row[0],
            plant_id=row[1],
            timestamp=row[2],
            nameplate_capacity_mw=row[3],
            net_summer_capacity_mw=row[4],
            net_winter_capacity_mw=row[5],
            planned_derate_summer_cap_mw=row[6],
            planned_uprate_summer_cap_mw=row[7],
            operating_year_month=row[8],
            planned_derate_year_month=row[9],
            planned_uprate_year_month=row[10],
            planned_retirement_year_month=row[11],
            source_timestamp=row[12],
            data_period=row[13],
            metadata=row[14],
            created_at=row[15],
        )

    async def create_metric(self, *, name: str, value: float, timestamp: Optional[datetime.datetime]) -> Optional[models.Metric]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_METRIC), {"p1": name, "p2": value, "p3": timestamp})).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )

    async def delete_metric(self, *, id: int) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_METRIC), {"p1": id})

    async def get_all_power_plants_with_latest_stats(self, arg: GetAllPowerPlantsWithLatestStatsParams) -> AsyncIterator[GetAllPowerPlantsWithLatestStatsRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_ALL_POWER_PLANTS_WITH_LATEST_STATS), {
            "p1": arg.fuel_type,
            "p2": arg.states,
            "p3": arg.operating_status,
            "p4": arg.min_capacity,
            "p5": arg.max_capacity,
        })
        async for row in result:
            yield GetAllPowerPlantsWithLatestStatsRow(
                id=row[0],
                api_plant_id=row[1],
                entity_id=row[2],
                name=row[3],
                county=row[4],
                state=row[5],
                longitude=row[6],
                latitude=row[7],
                plant_code=row[8],
                fuel_type=row[9],
                prime_mover=row[10],
                operating_status=row[11],
                plant_metadata=row[12],
                plant_created_at=row[13],
                plant_updated_at=row[14],
                stat_id=row[15],
                nameplate_capacity_mw=row[16],
                net_summer_capacity_mw=row[17],
                net_winter_capacity_mw=row[18],
                planned_derate_summer_cap_mw=row[19],
                planned_uprate_summer_cap_mw=row[20],
                operating_year_month=row[21],
                planned_derate_year_month=row[22],
                planned_uprate_year_month=row[23],
                planned_retirement_year_month=row[24],
                source_timestamp=row[25],
                data_period=row[26],
                stat_metadata=row[27],
                stat_timestamp=row[28],
            )

    async def get_eia_entity_by_api_id(self, *, api_entity_id: str) -> Optional[models.EiaEntity]:
        row = (await self._conn.execute(sqlalchemy.text(GET_EIA_ENTITY_BY_API_ID), {"p1": api_entity_id})).first()
        if row is None:
            return None
        return models.EiaEntity(
            id=row[0],
            api_entity_id=row[1],
            name=row[2],
            description=row[3],
            metadata=row[4],
            created_at=row[5],
            updated_at=row[6],
        )

    async def get_eia_plant_generation_by_plant_id(self, *, plant_id: Optional[int]) -> AsyncIterator[models.EiaPlantGeneration]:
        result = await self._conn.stream(sqlalchemy.text(GET_EIA_PLANT_GENERATION_BY_PLANT_ID), {"p1": plant_id})
        async for row in result:
            yield models.EiaPlantGeneration(
                id=row[0],
                plant_id=row[1],
                timestamp=row[2],
                period=row[3],
                generation=row[4],
                generation_units=row[5],
                gross_generation=row[6],
                gross_generation_units=row[7],
                consumption_for_eg=row[8],
                consumption_for_eg_units=row[9],
                consumption_for_eg_btu=row[10],
                consumption_for_eg_btu_units=row[11],
                total_consumption=row[12],
                total_consumption_units=row[13],
                total_consumption_btu=row[14],
                total_consumption_btu_units=row[15],
                average_heat_content=row[16],
                average_heat_content_units=row[17],
                source_timestamp=row[18],
                metadata=row[19],
                created_at=row[20],
            )

    async def get_eia_plant_generation_in_time_range(self, *, plant_id: Optional[int], start_timestamp: datetime.datetime, end_timestamp: datetime.datetime) -> AsyncIterator[models.EiaPlantGeneration]:
        result = await self._conn.stream(sqlalchemy.text(GET_EIA_PLANT_GENERATION_IN_TIME_RANGE), {"p1": plant_id, "p2": start_timestamp, "p3": end_timestamp})
        async for row in result:
            yield models.EiaPlantGeneration(
                id=row[0],
                plant_id=row[1],
                timestamp=row[2],
                period=row[3],
                generation=row[4],
                generation_units=row[5],
                gross_generation=row[6],
                gross_generation_units=row[7],
                consumption_for_eg=row[8],
                consumption_for_eg_units=row[9],
                consumption_for_eg_btu=row[10],
                consumption_for_eg_btu_units=row[11],
                total_consumption=row[12],
                total_consumption_units=row[13],
                total_consumption_btu=row[14],
                total_consumption_btu_units=row[15],
                average_heat_content=row[16],
                average_heat_content_units=row[17],
                source_timestamp=row[18],
                metadata=row[19],
                created_at=row[20],
            )

    async def get_eia_plant_stats_by_plant_id(self, *, plant_id: Optional[int]) -> AsyncIterator[models.EiaPlantCapacity]:
        result = await self._conn.stream(sqlalchemy.text(GET_EIA_PLANT_STATS_BY_PLANT_ID), {"p1": plant_id})
        async for row in result:
            yield models.EiaPlantCapacity(
                id=row[0],
                plant_id=row[1],
                timestamp=row[2],
                nameplate_capacity_mw=row[3],
                net_summer_capacity_mw=row[4],
                net_winter_capacity_mw=row[5],
                planned_derate_summer_cap_mw=row[6],
                planned_uprate_summer_cap_mw=row[7],
                operating_year_month=row[8],
                planned_derate_year_month=row[9],
                planned_uprate_year_month=row[10],
                planned_retirement_year_month=row[11],
                source_timestamp=row[12],
                data_period=row[13],
                metadata=row[14],
                created_at=row[15],
            )

    async def get_eia_plant_stats_in_time_range(self, *, plant_id: Optional[int], start_timestamp: datetime.datetime, end_timestamp: datetime.datetime) -> AsyncIterator[models.EiaPlantCapacity]:
        result = await self._conn.stream(sqlalchemy.text(GET_EIA_PLANT_STATS_IN_TIME_RANGE), {"p1": plant_id, "p2": start_timestamp, "p3": end_timestamp})
        async for row in result:
            yield models.EiaPlantCapacity(
                id=row[0],
                plant_id=row[1],
                timestamp=row[2],
                nameplate_capacity_mw=row[3],
                net_summer_capacity_mw=row[4],
                net_winter_capacity_mw=row[5],
                planned_derate_summer_cap_mw=row[6],
                planned_uprate_summer_cap_mw=row[7],
                operating_year_month=row[8],
                planned_derate_year_month=row[9],
                planned_uprate_year_month=row[10],
                planned_retirement_year_month=row[11],
                source_timestamp=row[12],
                data_period=row[13],
                metadata=row[14],
                created_at=row[15],
            )

    async def get_eia_power_plant_by_api_id(self, *, api_plant_id: str) -> Optional[models.EiaPowerPlant]:
        row = (await self._conn.execute(sqlalchemy.text(GET_EIA_POWER_PLANT_BY_API_ID), {"p1": api_plant_id})).first()
        if row is None:
            return None
        return models.EiaPowerPlant(
            id=row[0],
            api_plant_id=row[1],
            entity_id=row[2],
            name=row[3],
            county=row[4],
            state=row[5],
            location=row[6],
            plant_code=row[7],
            fuel_type=row[8],
            prime_mover=row[9],
            operating_status=row[10],
            metadata=row[11],
            created_at=row[12],
            updated_at=row[13],
        )

    async def get_eia_power_plants_for_entity(self, *, entity_id: Optional[int]) -> AsyncIterator[models.EiaPowerPlant]:
        result = await self._conn.stream(sqlalchemy.text(GET_EIA_POWER_PLANTS_FOR_ENTITY), {"p1": entity_id})
        async for row in result:
            yield models.EiaPowerPlant(
                id=row[0],
                api_plant_id=row[1],
                entity_id=row[2],
                name=row[3],
                county=row[4],
                state=row[5],
                location=row[6],
                plant_code=row[7],
                fuel_type=row[8],
                prime_mover=row[9],
                operating_status=row[10],
                metadata=row[11],
                created_at=row[12],
                updated_at=row[13],
            )

    async def get_latest_eia_plant_generation(self, *, plant_id: Optional[int]) -> Optional[models.EiaPlantGeneration]:
        row = (await self._conn.execute(sqlalchemy.text(GET_LATEST_EIA_PLANT_GENERATION), {"p1": plant_id})).first()
        if row is None:
            return None
        return models.EiaPlantGeneration(
            id=row[0],
            plant_id=row[1],
            timestamp=row[2],
            period=row[3],
            generation=row[4],
            generation_units=row[5],
            gross_generation=row[6],
            gross_generation_units=row[7],
            consumption_for_eg=row[8],
            consumption_for_eg_units=row[9],
            consumption_for_eg_btu=row[10],
            consumption_for_eg_btu_units=row[11],
            total_consumption=row[12],
            total_consumption_units=row[13],
            total_consumption_btu=row[14],
            total_consumption_btu_units=row[15],
            average_heat_content=row[16],
            average_heat_content_units=row[17],
            source_timestamp=row[18],
            metadata=row[19],
            created_at=row[20],
        )

    async def get_latest_eia_plant_stat(self, *, plant_id: Optional[int]) -> Optional[models.EiaPlantCapacity]:
        row = (await self._conn.execute(sqlalchemy.text(GET_LATEST_EIA_PLANT_STAT), {"p1": plant_id})).first()
        if row is None:
            return None
        return models.EiaPlantCapacity(
            id=row[0],
            plant_id=row[1],
            timestamp=row[2],
            nameplate_capacity_mw=row[3],
            net_summer_capacity_mw=row[4],
            net_winter_capacity_mw=row[5],
            planned_derate_summer_cap_mw=row[6],
            planned_uprate_summer_cap_mw=row[7],
            operating_year_month=row[8],
            planned_derate_year_month=row[9],
            planned_uprate_year_month=row[10],
            planned_retirement_year_month=row[11],
            source_timestamp=row[12],
            data_period=row[13],
            metadata=row[14],
            created_at=row[15],
        )

    async def get_metric(self, *, id: int) -> Optional[models.Metric]:
        row = (await self._conn.execute(sqlalchemy.text(GET_METRIC), {"p1": id})).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )

    async def get_metrics_by_name(self, *, name: str) -> AsyncIterator[models.Metric]:
        result = await self._conn.stream(sqlalchemy.text(GET_METRICS_BY_NAME), {"p1": name})
        async for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    async def get_metrics_by_time_range(self, *, start_timestamp: Optional[datetime.datetime], end_timestamp: Optional[datetime.datetime]) -> AsyncIterator[models.Metric]:
        result = await self._conn.stream(sqlalchemy.text(GET_METRICS_BY_TIME_RANGE), {"p1": start_timestamp, "p2": end_timestamp})
        async for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    async def list_metrics(self) -> AsyncIterator[models.Metric]:
        result = await self._conn.stream(sqlalchemy.text(LIST_METRICS))
        async for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    async def update_metric(self, *, id: int, name: str, value: float, timestamp: Optional[datetime.datetime]) -> Optional[models.Metric]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_METRIC), {
            "p1": id,
            "p2": name,
            "p3": value,
            "p4": timestamp,
        })).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )

    async def upsert_eia_entity(self, *, api_entity_id: str, name: str, description: Optional[str], metadata: Optional[Any]) -> Optional[models.EiaEntity]:
        row = (await self._conn.execute(sqlalchemy.text(UPSERT_EIA_ENTITY), {
            "p1": api_entity_id,
            "p2": name,
            "p3": description,
            "p4": metadata,
        })).first()
        if row is None:
            return None
        return models.EiaEntity(
            id=row[0],
            api_entity_id=row[1],
            name=row[2],
            description=row[3],
            metadata=row[4],
            created_at=row[5],
            updated_at=row[6],
        )

    async def upsert_eia_power_plant(self, arg: UpsertEIAPowerPlantParams) -> Optional[models.EiaPowerPlant]:
        row = (await self._conn.execute(sqlalchemy.text(UPSERT_EIA_POWER_PLANT), {
            "p1": arg.api_plant_id,
            "p2": arg.entity_id,
            "p3": arg.name,
            "p4": arg.county,
            "p5": arg.state,
            "p6": arg.longitude,
            "p7": arg.latitude,
            "p8": arg.plant_code,
            "p9": arg.fuel_type,
            "p10": arg.prime_mover,
            "p11": arg.operating_status,
            "p12": arg.metadata,
        })).first()
        if row is None:
            return None
        return models.EiaPowerPlant(
            id=row[0],
            api_plant_id=row[1],
            entity_id=row[2],
            name=row[3],
            county=row[4],
            state=row[5],
            location=row[6],
            plant_code=row[7],
            fuel_type=row[8],
            prime_mover=row[9],
            operating_status=row[10],
            metadata=row[11],
            created_at=row[12],
            updated_at=row[13],
        )
