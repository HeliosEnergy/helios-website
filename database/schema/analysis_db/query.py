# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: query.sql
import dataclasses
import datetime
from typing import Any, AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from analysis_db import models


CREATE_EIA_ELECTRICITY_DATA = """-- name: create_eia_electricity_data \\:exec
INSERT INTO eia_electricity_data (
    series_id,
    name,
    units,
    frequency,
    copyright,
    source,
    iso3166,
    location,
    geography,
    start_date,
    end_date,
    last_updated,
    data
) VALUES (
    :p1,
    :p2,
    :p3,
    :p4,
    :p5,
    :p6,
    :p7,
    ST_SetSRID(ST_MakePoint(
        :p8\\:\\:float8,
        :p9\\:\\:float8
    ), 4326)\\:\\:geography,
    :p10,
    :p11,
    :p12,
    :p13,
    :p14
)
"""


@dataclasses.dataclass()
class CreateEIAElectricityDataParams:
    series_id: str
    name: str
    units: str
    frequency: Optional[str]
    copyright: Optional[str]
    source: Optional[str]
    iso3166: Optional[str]
    longitude: float
    latitude: float
    geography: Optional[str]
    start_date: Optional[datetime.datetime]
    end_date: Optional[datetime.datetime]
    last_updated: Optional[datetime.datetime]
    data: Optional[Any]


CREATE_METRIC = """-- name: create_metric \\:one
INSERT INTO metrics (
    name,
    value,
    timestamp
) VALUES (
    :p1, :p2, :p3
) RETURNING id, name, value, timestamp
"""


DELETE_METRIC = """-- name: delete_metric \\:exec
DELETE FROM metrics
WHERE id = :p1
"""


GET_METRIC = """-- name: get_metric \\:one
SELECT id, name, value, timestamp FROM metrics
WHERE id = :p1
"""


GET_METRICS_BY_NAME = """-- name: get_metrics_by_name \\:many
SELECT id, name, value, timestamp FROM metrics
WHERE name = :p1
ORDER BY timestamp DESC
"""


GET_METRICS_BY_TIME_RANGE = """-- name: get_metrics_by_time_range \\:many
SELECT id, name, value, timestamp FROM metrics
WHERE timestamp BETWEEN :p1 AND :p2
ORDER BY timestamp DESC
"""


LIST_METRICS = """-- name: list_metrics \\:many
SELECT id, name, value, timestamp FROM metrics
ORDER BY timestamp DESC
"""


UPDATE_METRIC = """-- name: update_metric \\:one
UPDATE metrics
SET name = :p2,
    value = :p3,
    timestamp = :p4
WHERE id = :p1
RETURNING id, name, value, timestamp
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def create_eia_electricity_data(self, arg: CreateEIAElectricityDataParams) -> None:
        self._conn.execute(sqlalchemy.text(CREATE_EIA_ELECTRICITY_DATA), {
            "p1": arg.series_id,
            "p2": arg.name,
            "p3": arg.units,
            "p4": arg.frequency,
            "p5": arg.copyright,
            "p6": arg.source,
            "p7": arg.iso3166,
            "p8": arg.longitude,
            "p9": arg.latitude,
            "p10": arg.geography,
            "p11": arg.start_date,
            "p12": arg.end_date,
            "p13": arg.last_updated,
            "p14": arg.data,
        })

    def create_metric(self, *, name: str, value: float, timestamp: Optional[datetime.datetime]) -> Optional[models.Metric]:
        row = self._conn.execute(sqlalchemy.text(CREATE_METRIC), {"p1": name, "p2": value, "p3": timestamp}).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )

    def delete_metric(self, *, id: int) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_METRIC), {"p1": id})

    def get_metric(self, *, id: int) -> Optional[models.Metric]:
        row = self._conn.execute(sqlalchemy.text(GET_METRIC), {"p1": id}).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )

    def get_metrics_by_name(self, *, name: str) -> Iterator[models.Metric]:
        result = self._conn.execute(sqlalchemy.text(GET_METRICS_BY_NAME), {"p1": name})
        for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    def get_metrics_by_time_range(self, *, start_timestamp: Optional[datetime.datetime], end_timestamp: Optional[datetime.datetime]) -> Iterator[models.Metric]:
        result = self._conn.execute(sqlalchemy.text(GET_METRICS_BY_TIME_RANGE), {"p1": start_timestamp, "p2": end_timestamp})
        for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    def list_metrics(self) -> Iterator[models.Metric]:
        result = self._conn.execute(sqlalchemy.text(LIST_METRICS))
        for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    def update_metric(self, *, id: int, name: str, value: float, timestamp: Optional[datetime.datetime]) -> Optional[models.Metric]:
        row = self._conn.execute(sqlalchemy.text(UPDATE_METRIC), {
            "p1": id,
            "p2": name,
            "p3": value,
            "p4": timestamp,
        }).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_eia_electricity_data(self, arg: CreateEIAElectricityDataParams) -> None:
        await self._conn.execute(sqlalchemy.text(CREATE_EIA_ELECTRICITY_DATA), {
            "p1": arg.series_id,
            "p2": arg.name,
            "p3": arg.units,
            "p4": arg.frequency,
            "p5": arg.copyright,
            "p6": arg.source,
            "p7": arg.iso3166,
            "p8": arg.longitude,
            "p9": arg.latitude,
            "p10": arg.geography,
            "p11": arg.start_date,
            "p12": arg.end_date,
            "p13": arg.last_updated,
            "p14": arg.data,
        })

    async def create_metric(self, *, name: str, value: float, timestamp: Optional[datetime.datetime]) -> Optional[models.Metric]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_METRIC), {"p1": name, "p2": value, "p3": timestamp})).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )

    async def delete_metric(self, *, id: int) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_METRIC), {"p1": id})

    async def get_metric(self, *, id: int) -> Optional[models.Metric]:
        row = (await self._conn.execute(sqlalchemy.text(GET_METRIC), {"p1": id})).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )

    async def get_metrics_by_name(self, *, name: str) -> AsyncIterator[models.Metric]:
        result = await self._conn.stream(sqlalchemy.text(GET_METRICS_BY_NAME), {"p1": name})
        async for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    async def get_metrics_by_time_range(self, *, start_timestamp: Optional[datetime.datetime], end_timestamp: Optional[datetime.datetime]) -> AsyncIterator[models.Metric]:
        result = await self._conn.stream(sqlalchemy.text(GET_METRICS_BY_TIME_RANGE), {"p1": start_timestamp, "p2": end_timestamp})
        async for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    async def list_metrics(self) -> AsyncIterator[models.Metric]:
        result = await self._conn.stream(sqlalchemy.text(LIST_METRICS))
        async for row in result:
            yield models.Metric(
                id=row[0],
                name=row[1],
                value=row[2],
                timestamp=row[3],
            )

    async def update_metric(self, *, id: int, name: str, value: float, timestamp: Optional[datetime.datetime]) -> Optional[models.Metric]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_METRIC), {
            "p1": id,
            "p2": name,
            "p3": value,
            "p4": timestamp,
        })).first()
        if row is None:
            return None
        return models.Metric(
            id=row[0],
            name=row[1],
            value=row[2],
            timestamp=row[3],
        )
