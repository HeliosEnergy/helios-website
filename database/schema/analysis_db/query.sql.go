// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package analysis_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEIAElectricityData = `-- name: CreateEIAElectricityData :exec
INSERT INTO eia_bulk_electricity_data (
    series_id,
    name,
    units,
    frequency,
    copyright,
    source,
    iso3166,
    location,
    geography,
    start_date,
    end_date,
    last_updated,
    data
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    ST_SetSRID(ST_MakePoint(
        $8::float8,
        $9::float8
    ), 4326)::geography,
    $10,
    $11,
    $12,
    $13,
    $14
)
`

type CreateEIAElectricityDataParams struct {
	SeriesID    string
	Name        string
	Units       string
	Frequency   pgtype.Text
	Copyright   pgtype.Text
	Source      pgtype.Text
	Iso3166     pgtype.Text
	Longitude   float64
	Latitude    float64
	Geography   pgtype.Text
	StartDate   pgtype.Timestamptz
	EndDate     pgtype.Timestamptz
	LastUpdated pgtype.Timestamptz
	Data        []byte
}

func (q *Queries) CreateEIAElectricityData(ctx context.Context, arg CreateEIAElectricityDataParams) error {
	_, err := q.db.Exec(ctx, createEIAElectricityData,
		arg.SeriesID,
		arg.Name,
		arg.Units,
		arg.Frequency,
		arg.Copyright,
		arg.Source,
		arg.Iso3166,
		arg.Longitude,
		arg.Latitude,
		arg.Geography,
		arg.StartDate,
		arg.EndDate,
		arg.LastUpdated,
		arg.Data,
	)
	return err
}

const createEIAPlantGeneration = `-- name: CreateEIAPlantGeneration :one
INSERT INTO eia_plant_generation (
    plant_id,
    timestamp,
    period,
    generation,
    generation_units,
    gross_generation,
    gross_generation_units,
    consumption_for_eg,
    consumption_for_eg_units,
    consumption_for_eg_btu,
    consumption_for_eg_btu_units,
    total_consumption,
    total_consumption_units,
    total_consumption_btu,
    total_consumption_btu_units,
    average_heat_content,
    average_heat_content_units,
    source_timestamp,
    metadata
) VALUES (
    $1,
    COALESCE($2, CURRENT_TIMESTAMP),
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19
)
RETURNING id, plant_id, timestamp, period, generation, generation_units, gross_generation, gross_generation_units, consumption_for_eg, consumption_for_eg_units, consumption_for_eg_btu, consumption_for_eg_btu_units, total_consumption, total_consumption_units, total_consumption_btu, total_consumption_btu_units, average_heat_content, average_heat_content_units, source_timestamp, metadata, created_at
`

type CreateEIAPlantGenerationParams struct {
	PlantID                  pgtype.Int4
	Timestamp                interface{}
	Period                   pgtype.Text
	Generation               pgtype.Float8
	GenerationUnits          pgtype.Text
	GrossGeneration          pgtype.Float8
	GrossGenerationUnits     pgtype.Text
	ConsumptionForEg         pgtype.Float8
	ConsumptionForEgUnits    pgtype.Text
	ConsumptionForEgBtu      pgtype.Float8
	ConsumptionForEgBtuUnits pgtype.Text
	TotalConsumption         pgtype.Float8
	TotalConsumptionUnits    pgtype.Text
	TotalConsumptionBtu      pgtype.Float8
	TotalConsumptionBtuUnits pgtype.Text
	AverageHeatContent       pgtype.Float8
	AverageHeatContentUnits  pgtype.Text
	SourceTimestamp          pgtype.Timestamptz
	Metadata                 []byte
}

func (q *Queries) CreateEIAPlantGeneration(ctx context.Context, arg CreateEIAPlantGenerationParams) (EiaPlantGeneration, error) {
	row := q.db.QueryRow(ctx, createEIAPlantGeneration,
		arg.PlantID,
		arg.Timestamp,
		arg.Period,
		arg.Generation,
		arg.GenerationUnits,
		arg.GrossGeneration,
		arg.GrossGenerationUnits,
		arg.ConsumptionForEg,
		arg.ConsumptionForEgUnits,
		arg.ConsumptionForEgBtu,
		arg.ConsumptionForEgBtuUnits,
		arg.TotalConsumption,
		arg.TotalConsumptionUnits,
		arg.TotalConsumptionBtu,
		arg.TotalConsumptionBtuUnits,
		arg.AverageHeatContent,
		arg.AverageHeatContentUnits,
		arg.SourceTimestamp,
		arg.Metadata,
	)
	var i EiaPlantGeneration
	err := row.Scan(
		&i.ID,
		&i.PlantID,
		&i.Timestamp,
		&i.Period,
		&i.Generation,
		&i.GenerationUnits,
		&i.GrossGeneration,
		&i.GrossGenerationUnits,
		&i.ConsumptionForEg,
		&i.ConsumptionForEgUnits,
		&i.ConsumptionForEgBtu,
		&i.ConsumptionForEgBtuUnits,
		&i.TotalConsumption,
		&i.TotalConsumptionUnits,
		&i.TotalConsumptionBtu,
		&i.TotalConsumptionBtuUnits,
		&i.AverageHeatContent,
		&i.AverageHeatContentUnits,
		&i.SourceTimestamp,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createEIAPlantStat = `-- name: CreateEIAPlantStat :one
INSERT INTO eia_plant_capacity (
    plant_id,
    timestamp,
    nameplate_capacity_mw,
    net_summer_capacity_mw,
    net_winter_capacity_mw,
    planned_derate_summer_cap_mw,
    planned_uprate_summer_cap_mw,
    operating_year_month,
    planned_derate_year_month,
    planned_uprate_year_month,
    planned_retirement_year_month,
    source_timestamp,
    data_period,
    metadata
) VALUES (
    $1,
    COALESCE($2, CURRENT_TIMESTAMP),
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14
)
RETURNING id, plant_id, timestamp, nameplate_capacity_mw, net_summer_capacity_mw, net_winter_capacity_mw, planned_derate_summer_cap_mw, planned_uprate_summer_cap_mw, operating_year_month, planned_derate_year_month, planned_uprate_year_month, planned_retirement_year_month, source_timestamp, data_period, metadata, created_at
`

type CreateEIAPlantStatParams struct {
	PlantID                    pgtype.Int4
	Timestamp                  interface{}
	NameplateCapacityMw        pgtype.Float8
	NetSummerCapacityMw        pgtype.Float8
	NetWinterCapacityMw        pgtype.Float8
	PlannedDerateSummerCapMw   pgtype.Float8
	PlannedUprateSummerCapMw   pgtype.Float8
	OperatingYearMonth         pgtype.Date
	PlannedDerateYearMonth     pgtype.Date
	PlannedUprateYearMonth     pgtype.Date
	PlannedRetirementYearMonth pgtype.Date
	SourceTimestamp            pgtype.Timestamptz
	DataPeriod                 pgtype.Text
	Metadata                   []byte
}

func (q *Queries) CreateEIAPlantStat(ctx context.Context, arg CreateEIAPlantStatParams) (EiaPlantCapacity, error) {
	row := q.db.QueryRow(ctx, createEIAPlantStat,
		arg.PlantID,
		arg.Timestamp,
		arg.NameplateCapacityMw,
		arg.NetSummerCapacityMw,
		arg.NetWinterCapacityMw,
		arg.PlannedDerateSummerCapMw,
		arg.PlannedUprateSummerCapMw,
		arg.OperatingYearMonth,
		arg.PlannedDerateYearMonth,
		arg.PlannedUprateYearMonth,
		arg.PlannedRetirementYearMonth,
		arg.SourceTimestamp,
		arg.DataPeriod,
		arg.Metadata,
	)
	var i EiaPlantCapacity
	err := row.Scan(
		&i.ID,
		&i.PlantID,
		&i.Timestamp,
		&i.NameplateCapacityMw,
		&i.NetSummerCapacityMw,
		&i.NetWinterCapacityMw,
		&i.PlannedDerateSummerCapMw,
		&i.PlannedUprateSummerCapMw,
		&i.OperatingYearMonth,
		&i.PlannedDerateYearMonth,
		&i.PlannedUprateYearMonth,
		&i.PlannedRetirementYearMonth,
		&i.SourceTimestamp,
		&i.DataPeriod,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createMetric = `-- name: CreateMetric :one
INSERT INTO metrics (
    name,
    value,
    timestamp
) VALUES (
    $1, $2, $3
) RETURNING id, name, value, timestamp
`

type CreateMetricParams struct {
	Name      string
	Value     float64
	Timestamp pgtype.Timestamptz
}

func (q *Queries) CreateMetric(ctx context.Context, arg CreateMetricParams) (Metric, error) {
	row := q.db.QueryRow(ctx, createMetric, arg.Name, arg.Value, arg.Timestamp)
	var i Metric
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Value,
		&i.Timestamp,
	)
	return i, err
}

const deleteMetric = `-- name: DeleteMetric :exec
DELETE FROM metrics
WHERE id = $1
`

func (q *Queries) DeleteMetric(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMetric, id)
	return err
}

const getAllPowerPlantsWithLatestStats = `-- name: GetAllPowerPlantsWithLatestStats :many
SELECT 
    p.id, 
    p.api_plant_id, 
    p.entity_id, 
    p.name, 
    p.county, 
    p.state,
    ST_X(p.location::geometry) AS longitude,
    ST_Y(p.location::geometry) AS latitude,
    p.plant_code,
    p.fuel_type,
    p.prime_mover,
    p.operating_status,
    p.metadata AS plant_metadata,
    p.created_at AS plant_created_at,
    p.updated_at AS plant_updated_at,
    s.id AS stat_id,
    s.nameplate_capacity_mw,
    s.net_summer_capacity_mw,
    s.net_winter_capacity_mw,
    s.planned_derate_summer_cap_mw,
    s.planned_uprate_summer_cap_mw,
    s.operating_year_month,
    s.planned_derate_year_month,
    s.planned_uprate_year_month,
    s.planned_retirement_year_month,
    s.source_timestamp,
    s.data_period,
    s.metadata AS stat_metadata,
    s.timestamp AS stat_timestamp
FROM eia_power_plants as p
LEFT JOIN (
    SELECT DISTINCT ON (plant_id) id, plant_id, timestamp, nameplate_capacity_mw, net_summer_capacity_mw, net_winter_capacity_mw, planned_derate_summer_cap_mw, planned_uprate_summer_cap_mw, operating_year_month, planned_derate_year_month, planned_uprate_year_month, planned_retirement_year_month, source_timestamp, data_period, metadata, created_at
    FROM eia_plant_capacity
    ORDER BY plant_id, timestamp DESC
) as s ON s.plant_id = p.id
WHERE 
    ($1::text IS NULL OR p.fuel_type = $1)
    AND (
        $2::text[] IS NULL 
        OR $2::text[] = '{}'::text[] 
        OR p.state = ANY($2::text[])
    )
    AND ($3::text IS NULL OR p.operating_status = $3)
    AND (
        $4::float IS NULL 
        OR (s.nameplate_capacity_mw IS NOT NULL AND s.nameplate_capacity_mw >= $4)
    )
    AND (
        $5::float IS NULL 
        OR (s.nameplate_capacity_mw IS NOT NULL AND s.nameplate_capacity_mw <= $5)
    )
`

type GetAllPowerPlantsWithLatestStatsParams struct {
	FuelType        pgtype.Text
	States          []string
	OperatingStatus pgtype.Text
	MinCapacity     pgtype.Float8
	MaxCapacity     pgtype.Float8
}

type GetAllPowerPlantsWithLatestStatsRow struct {
	ID                         int32
	ApiPlantID                 string
	EntityID                   pgtype.Int4
	Name                       string
	County                     pgtype.Text
	State                      pgtype.Text
	Longitude                  interface{}
	Latitude                   interface{}
	PlantCode                  pgtype.Text
	FuelType                   pgtype.Text
	PrimeMover                 pgtype.Text
	OperatingStatus            pgtype.Text
	PlantMetadata              []byte
	PlantCreatedAt             pgtype.Timestamptz
	PlantUpdatedAt             pgtype.Timestamptz
	StatID                     int32
	NameplateCapacityMw        pgtype.Float8
	NetSummerCapacityMw        pgtype.Float8
	NetWinterCapacityMw        pgtype.Float8
	PlannedDerateSummerCapMw   pgtype.Float8
	PlannedUprateSummerCapMw   pgtype.Float8
	OperatingYearMonth         pgtype.Date
	PlannedDerateYearMonth     pgtype.Date
	PlannedUprateYearMonth     pgtype.Date
	PlannedRetirementYearMonth pgtype.Date
	SourceTimestamp            pgtype.Timestamptz
	DataPeriod                 pgtype.Text
	StatMetadata               []byte
	StatTimestamp              pgtype.Timestamptz
}

func (q *Queries) GetAllPowerPlantsWithLatestStats(ctx context.Context, arg GetAllPowerPlantsWithLatestStatsParams) ([]GetAllPowerPlantsWithLatestStatsRow, error) {
	rows, err := q.db.Query(ctx, getAllPowerPlantsWithLatestStats,
		arg.FuelType,
		arg.States,
		arg.OperatingStatus,
		arg.MinCapacity,
		arg.MaxCapacity,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPowerPlantsWithLatestStatsRow
	for rows.Next() {
		var i GetAllPowerPlantsWithLatestStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.ApiPlantID,
			&i.EntityID,
			&i.Name,
			&i.County,
			&i.State,
			&i.Longitude,
			&i.Latitude,
			&i.PlantCode,
			&i.FuelType,
			&i.PrimeMover,
			&i.OperatingStatus,
			&i.PlantMetadata,
			&i.PlantCreatedAt,
			&i.PlantUpdatedAt,
			&i.StatID,
			&i.NameplateCapacityMw,
			&i.NetSummerCapacityMw,
			&i.NetWinterCapacityMw,
			&i.PlannedDerateSummerCapMw,
			&i.PlannedUprateSummerCapMw,
			&i.OperatingYearMonth,
			&i.PlannedDerateYearMonth,
			&i.PlannedUprateYearMonth,
			&i.PlannedRetirementYearMonth,
			&i.SourceTimestamp,
			&i.DataPeriod,
			&i.StatMetadata,
			&i.StatTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEIAEntityByApiID = `-- name: GetEIAEntityByApiID :one

SELECT id, api_entity_id, name, description, metadata, created_at, updated_at FROM eia_entities
WHERE api_entity_id = $1
`

// New queries for EIA entities, plants, and stats
func (q *Queries) GetEIAEntityByApiID(ctx context.Context, apiEntityID string) (EiaEntity, error) {
	row := q.db.QueryRow(ctx, getEIAEntityByApiID, apiEntityID)
	var i EiaEntity
	err := row.Scan(
		&i.ID,
		&i.ApiEntityID,
		&i.Name,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEIAPlantGenerationByPlantID = `-- name: GetEIAPlantGenerationByPlantID :many
SELECT id, plant_id, timestamp, period, generation, generation_units, gross_generation, gross_generation_units, consumption_for_eg, consumption_for_eg_units, consumption_for_eg_btu, consumption_for_eg_btu_units, total_consumption, total_consumption_units, total_consumption_btu, total_consumption_btu_units, average_heat_content, average_heat_content_units, source_timestamp, metadata, created_at FROM eia_plant_generation
WHERE plant_id = $1
ORDER BY timestamp DESC
`

func (q *Queries) GetEIAPlantGenerationByPlantID(ctx context.Context, plantID pgtype.Int4) ([]EiaPlantGeneration, error) {
	rows, err := q.db.Query(ctx, getEIAPlantGenerationByPlantID, plantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EiaPlantGeneration
	for rows.Next() {
		var i EiaPlantGeneration
		if err := rows.Scan(
			&i.ID,
			&i.PlantID,
			&i.Timestamp,
			&i.Period,
			&i.Generation,
			&i.GenerationUnits,
			&i.GrossGeneration,
			&i.GrossGenerationUnits,
			&i.ConsumptionForEg,
			&i.ConsumptionForEgUnits,
			&i.ConsumptionForEgBtu,
			&i.ConsumptionForEgBtuUnits,
			&i.TotalConsumption,
			&i.TotalConsumptionUnits,
			&i.TotalConsumptionBtu,
			&i.TotalConsumptionBtuUnits,
			&i.AverageHeatContent,
			&i.AverageHeatContentUnits,
			&i.SourceTimestamp,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEIAPlantGenerationInTimeRange = `-- name: GetEIAPlantGenerationInTimeRange :many
SELECT id, plant_id, timestamp, period, generation, generation_units, gross_generation, gross_generation_units, consumption_for_eg, consumption_for_eg_units, consumption_for_eg_btu, consumption_for_eg_btu_units, total_consumption, total_consumption_units, total_consumption_btu, total_consumption_btu_units, average_heat_content, average_heat_content_units, source_timestamp, metadata, created_at FROM eia_plant_generation
WHERE plant_id = $1
AND timestamp BETWEEN $2 AND $3
ORDER BY timestamp DESC
`

type GetEIAPlantGenerationInTimeRangeParams struct {
	PlantID        pgtype.Int4
	StartTimestamp pgtype.Timestamptz
	EndTimestamp   pgtype.Timestamptz
}

func (q *Queries) GetEIAPlantGenerationInTimeRange(ctx context.Context, arg GetEIAPlantGenerationInTimeRangeParams) ([]EiaPlantGeneration, error) {
	rows, err := q.db.Query(ctx, getEIAPlantGenerationInTimeRange, arg.PlantID, arg.StartTimestamp, arg.EndTimestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EiaPlantGeneration
	for rows.Next() {
		var i EiaPlantGeneration
		if err := rows.Scan(
			&i.ID,
			&i.PlantID,
			&i.Timestamp,
			&i.Period,
			&i.Generation,
			&i.GenerationUnits,
			&i.GrossGeneration,
			&i.GrossGenerationUnits,
			&i.ConsumptionForEg,
			&i.ConsumptionForEgUnits,
			&i.ConsumptionForEgBtu,
			&i.ConsumptionForEgBtuUnits,
			&i.TotalConsumption,
			&i.TotalConsumptionUnits,
			&i.TotalConsumptionBtu,
			&i.TotalConsumptionBtuUnits,
			&i.AverageHeatContent,
			&i.AverageHeatContentUnits,
			&i.SourceTimestamp,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEIAPlantStatsByPlantID = `-- name: GetEIAPlantStatsByPlantID :many
SELECT id, plant_id, timestamp, nameplate_capacity_mw, net_summer_capacity_mw, net_winter_capacity_mw, planned_derate_summer_cap_mw, planned_uprate_summer_cap_mw, operating_year_month, planned_derate_year_month, planned_uprate_year_month, planned_retirement_year_month, source_timestamp, data_period, metadata, created_at FROM eia_plant_capacity
WHERE plant_id = $1
ORDER BY timestamp DESC
`

func (q *Queries) GetEIAPlantStatsByPlantID(ctx context.Context, plantID pgtype.Int4) ([]EiaPlantCapacity, error) {
	rows, err := q.db.Query(ctx, getEIAPlantStatsByPlantID, plantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EiaPlantCapacity
	for rows.Next() {
		var i EiaPlantCapacity
		if err := rows.Scan(
			&i.ID,
			&i.PlantID,
			&i.Timestamp,
			&i.NameplateCapacityMw,
			&i.NetSummerCapacityMw,
			&i.NetWinterCapacityMw,
			&i.PlannedDerateSummerCapMw,
			&i.PlannedUprateSummerCapMw,
			&i.OperatingYearMonth,
			&i.PlannedDerateYearMonth,
			&i.PlannedUprateYearMonth,
			&i.PlannedRetirementYearMonth,
			&i.SourceTimestamp,
			&i.DataPeriod,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEIAPlantStatsInTimeRange = `-- name: GetEIAPlantStatsInTimeRange :many
SELECT id, plant_id, timestamp, nameplate_capacity_mw, net_summer_capacity_mw, net_winter_capacity_mw, planned_derate_summer_cap_mw, planned_uprate_summer_cap_mw, operating_year_month, planned_derate_year_month, planned_uprate_year_month, planned_retirement_year_month, source_timestamp, data_period, metadata, created_at FROM eia_plant_capacity
WHERE plant_id = $1
AND timestamp BETWEEN $2 AND $3
ORDER BY timestamp DESC
`

type GetEIAPlantStatsInTimeRangeParams struct {
	PlantID        pgtype.Int4
	StartTimestamp pgtype.Timestamptz
	EndTimestamp   pgtype.Timestamptz
}

func (q *Queries) GetEIAPlantStatsInTimeRange(ctx context.Context, arg GetEIAPlantStatsInTimeRangeParams) ([]EiaPlantCapacity, error) {
	rows, err := q.db.Query(ctx, getEIAPlantStatsInTimeRange, arg.PlantID, arg.StartTimestamp, arg.EndTimestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EiaPlantCapacity
	for rows.Next() {
		var i EiaPlantCapacity
		if err := rows.Scan(
			&i.ID,
			&i.PlantID,
			&i.Timestamp,
			&i.NameplateCapacityMw,
			&i.NetSummerCapacityMw,
			&i.NetWinterCapacityMw,
			&i.PlannedDerateSummerCapMw,
			&i.PlannedUprateSummerCapMw,
			&i.OperatingYearMonth,
			&i.PlannedDerateYearMonth,
			&i.PlannedUprateYearMonth,
			&i.PlannedRetirementYearMonth,
			&i.SourceTimestamp,
			&i.DataPeriod,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEIAPowerPlantByApiID = `-- name: GetEIAPowerPlantByApiID :one
SELECT id, api_plant_id, entity_id, name, county, state, location, plant_code, fuel_type, prime_mover, operating_status, metadata, created_at, updated_at FROM eia_power_plants
WHERE api_plant_id = $1
`

func (q *Queries) GetEIAPowerPlantByApiID(ctx context.Context, apiPlantID string) (EiaPowerPlant, error) {
	row := q.db.QueryRow(ctx, getEIAPowerPlantByApiID, apiPlantID)
	var i EiaPowerPlant
	err := row.Scan(
		&i.ID,
		&i.ApiPlantID,
		&i.EntityID,
		&i.Name,
		&i.County,
		&i.State,
		&i.Location,
		&i.PlantCode,
		&i.FuelType,
		&i.PrimeMover,
		&i.OperatingStatus,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEIAPowerPlantsForEntity = `-- name: GetEIAPowerPlantsForEntity :many
SELECT id, api_plant_id, entity_id, name, county, state, location, plant_code, fuel_type, prime_mover, operating_status, metadata, created_at, updated_at FROM eia_power_plants
WHERE entity_id = $1
`

func (q *Queries) GetEIAPowerPlantsForEntity(ctx context.Context, entityID pgtype.Int4) ([]EiaPowerPlant, error) {
	rows, err := q.db.Query(ctx, getEIAPowerPlantsForEntity, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EiaPowerPlant
	for rows.Next() {
		var i EiaPowerPlant
		if err := rows.Scan(
			&i.ID,
			&i.ApiPlantID,
			&i.EntityID,
			&i.Name,
			&i.County,
			&i.State,
			&i.Location,
			&i.PlantCode,
			&i.FuelType,
			&i.PrimeMover,
			&i.OperatingStatus,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestEIAPlantGeneration = `-- name: GetLatestEIAPlantGeneration :one
SELECT id, plant_id, timestamp, period, generation, generation_units, gross_generation, gross_generation_units, consumption_for_eg, consumption_for_eg_units, consumption_for_eg_btu, consumption_for_eg_btu_units, total_consumption, total_consumption_units, total_consumption_btu, total_consumption_btu_units, average_heat_content, average_heat_content_units, source_timestamp, metadata, created_at FROM eia_plant_generation
WHERE plant_id = $1
ORDER BY timestamp DESC
LIMIT 1
`

func (q *Queries) GetLatestEIAPlantGeneration(ctx context.Context, plantID pgtype.Int4) (EiaPlantGeneration, error) {
	row := q.db.QueryRow(ctx, getLatestEIAPlantGeneration, plantID)
	var i EiaPlantGeneration
	err := row.Scan(
		&i.ID,
		&i.PlantID,
		&i.Timestamp,
		&i.Period,
		&i.Generation,
		&i.GenerationUnits,
		&i.GrossGeneration,
		&i.GrossGenerationUnits,
		&i.ConsumptionForEg,
		&i.ConsumptionForEgUnits,
		&i.ConsumptionForEgBtu,
		&i.ConsumptionForEgBtuUnits,
		&i.TotalConsumption,
		&i.TotalConsumptionUnits,
		&i.TotalConsumptionBtu,
		&i.TotalConsumptionBtuUnits,
		&i.AverageHeatContent,
		&i.AverageHeatContentUnits,
		&i.SourceTimestamp,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestEIAPlantStat = `-- name: GetLatestEIAPlantStat :one
SELECT id, plant_id, timestamp, nameplate_capacity_mw, net_summer_capacity_mw, net_winter_capacity_mw, planned_derate_summer_cap_mw, planned_uprate_summer_cap_mw, operating_year_month, planned_derate_year_month, planned_uprate_year_month, planned_retirement_year_month, source_timestamp, data_period, metadata, created_at FROM eia_plant_capacity
WHERE plant_id = $1
ORDER BY timestamp DESC
LIMIT 1
`

func (q *Queries) GetLatestEIAPlantStat(ctx context.Context, plantID pgtype.Int4) (EiaPlantCapacity, error) {
	row := q.db.QueryRow(ctx, getLatestEIAPlantStat, plantID)
	var i EiaPlantCapacity
	err := row.Scan(
		&i.ID,
		&i.PlantID,
		&i.Timestamp,
		&i.NameplateCapacityMw,
		&i.NetSummerCapacityMw,
		&i.NetWinterCapacityMw,
		&i.PlannedDerateSummerCapMw,
		&i.PlannedUprateSummerCapMw,
		&i.OperatingYearMonth,
		&i.PlannedDerateYearMonth,
		&i.PlannedUprateYearMonth,
		&i.PlannedRetirementYearMonth,
		&i.SourceTimestamp,
		&i.DataPeriod,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getMetric = `-- name: GetMetric :one
SELECT id, name, value, timestamp FROM metrics
WHERE id = $1
`

func (q *Queries) GetMetric(ctx context.Context, id int32) (Metric, error) {
	row := q.db.QueryRow(ctx, getMetric, id)
	var i Metric
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Value,
		&i.Timestamp,
	)
	return i, err
}

const getMetricsByName = `-- name: GetMetricsByName :many
SELECT id, name, value, timestamp FROM metrics
WHERE name = $1
ORDER BY timestamp DESC
`

func (q *Queries) GetMetricsByName(ctx context.Context, name string) ([]Metric, error) {
	rows, err := q.db.Query(ctx, getMetricsByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Value,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricsByTimeRange = `-- name: GetMetricsByTimeRange :many
SELECT id, name, value, timestamp FROM metrics
WHERE timestamp BETWEEN $1 AND $2
ORDER BY timestamp DESC
`

type GetMetricsByTimeRangeParams struct {
	StartTimestamp pgtype.Timestamptz
	EndTimestamp   pgtype.Timestamptz
}

func (q *Queries) GetMetricsByTimeRange(ctx context.Context, arg GetMetricsByTimeRangeParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, getMetricsByTimeRange, arg.StartTimestamp, arg.EndTimestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Value,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetrics = `-- name: ListMetrics :many
SELECT id, name, value, timestamp FROM metrics
ORDER BY timestamp DESC
`

func (q *Queries) ListMetrics(ctx context.Context) ([]Metric, error) {
	rows, err := q.db.Query(ctx, listMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Value,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMetric = `-- name: UpdateMetric :one
UPDATE metrics
SET name = $2,
    value = $3,
    timestamp = $4
WHERE id = $1
RETURNING id, name, value, timestamp
`

type UpdateMetricParams struct {
	ID        int32
	Name      string
	Value     float64
	Timestamp pgtype.Timestamptz
}

func (q *Queries) UpdateMetric(ctx context.Context, arg UpdateMetricParams) (Metric, error) {
	row := q.db.QueryRow(ctx, updateMetric,
		arg.ID,
		arg.Name,
		arg.Value,
		arg.Timestamp,
	)
	var i Metric
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Value,
		&i.Timestamp,
	)
	return i, err
}

const upsertEIAEntity = `-- name: UpsertEIAEntity :one
INSERT INTO eia_entities (
    api_entity_id,
    name,
    description,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4
)
ON CONFLICT (api_entity_id) 
DO UPDATE SET
    name = EXCLUDED.name,
    description = EXCLUDED.description,
    metadata = EXCLUDED.metadata,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, api_entity_id, name, description, metadata, created_at, updated_at
`

type UpsertEIAEntityParams struct {
	ApiEntityID string
	Name        string
	Description pgtype.Text
	Metadata    []byte
}

func (q *Queries) UpsertEIAEntity(ctx context.Context, arg UpsertEIAEntityParams) (EiaEntity, error) {
	row := q.db.QueryRow(ctx, upsertEIAEntity,
		arg.ApiEntityID,
		arg.Name,
		arg.Description,
		arg.Metadata,
	)
	var i EiaEntity
	err := row.Scan(
		&i.ID,
		&i.ApiEntityID,
		&i.Name,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertEIAPowerPlant = `-- name: UpsertEIAPowerPlant :one
INSERT INTO eia_power_plants (
    api_plant_id,
    entity_id,
    name,
    county,
    state,
    location,
    plant_code,
    fuel_type,
    prime_mover,
    operating_status,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    ST_SetSRID(ST_MakePoint(
        $6::float8,
        $7::float8
    ), 4326)::geography,
    $8,
    $9,
    $10,
    $11,
    $12
)
ON CONFLICT (api_plant_id) 
DO UPDATE SET
    entity_id = EXCLUDED.entity_id,
    name = EXCLUDED.name,
    county = EXCLUDED.county,
    state = EXCLUDED.state,
    location = EXCLUDED.location,
    plant_code = EXCLUDED.plant_code,
    fuel_type = EXCLUDED.fuel_type,
    prime_mover = EXCLUDED.prime_mover,
    operating_status = EXCLUDED.operating_status,
    metadata = EXCLUDED.metadata,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, api_plant_id, entity_id, name, county, state, location, plant_code, fuel_type, prime_mover, operating_status, metadata, created_at, updated_at
`

type UpsertEIAPowerPlantParams struct {
	ApiPlantID      string
	EntityID        pgtype.Int4
	Name            string
	County          pgtype.Text
	State           pgtype.Text
	Longitude       float64
	Latitude        float64
	PlantCode       pgtype.Text
	FuelType        pgtype.Text
	PrimeMover      pgtype.Text
	OperatingStatus pgtype.Text
	Metadata        []byte
}

func (q *Queries) UpsertEIAPowerPlant(ctx context.Context, arg UpsertEIAPowerPlantParams) (EiaPowerPlant, error) {
	row := q.db.QueryRow(ctx, upsertEIAPowerPlant,
		arg.ApiPlantID,
		arg.EntityID,
		arg.Name,
		arg.County,
		arg.State,
		arg.Longitude,
		arg.Latitude,
		arg.PlantCode,
		arg.FuelType,
		arg.PrimeMover,
		arg.OperatingStatus,
		arg.Metadata,
	)
	var i EiaPowerPlant
	err := row.Scan(
		&i.ID,
		&i.ApiPlantID,
		&i.EntityID,
		&i.Name,
		&i.County,
		&i.State,
		&i.Location,
		&i.PlantCode,
		&i.FuelType,
		&i.PrimeMover,
		&i.OperatingStatus,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
