# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: query.sql
from typing import AsyncIterator, Iterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from authors import models


CREATE_USER = """-- name: create_user \\:one
INSERT INTO account (
	account_type,
	name,
	email,
	password
) VALUES (
	:p1,
	:p2,
	:p3,
	:p4
)
RETURNING id, tag, account_type, name, email, password, data, created_at, updated_at, deleted_at
"""


GET_TENANT = """-- name: get_tenant \\:one
SELECT id, tag, name, description, data, created_at, updated_at, deleted_at FROM tenant
WHERE id = :p1 LIMIT 1
"""


GET_USER_BY_EMAIL = """-- name: get_user_by_email \\:one
SELECT id, tag, account_type, name, email, password, data, created_at, updated_at, deleted_at
FROM account
WHERE email = :p1
LIMIT 1
"""


GET_USER_BY_TAG = """-- name: get_user_by_tag \\:one
SELECT id, tag, account_type, name, email, password, data, created_at, updated_at, deleted_at
FROM account
WHERE tag = :p1
LIMIT 1
"""


LIST_TENANTS = """-- name: list_tenants \\:many
SELECT id, tag, name, description, data, created_at, updated_at, deleted_at FROM tenant
ORDER BY name
"""


UPDATE_TENANT = """-- name: update_tenant \\:exec


DELETE FROM tenant
WHERE id = :p1
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def create_user(self, *, account_type: models.AccountType, name: str, email: str, password: Optional[str]) -> Optional[models.Account]:
        row = self._conn.execute(sqlalchemy.text(CREATE_USER), {
            "p1": account_type,
            "p2": name,
            "p3": email,
            "p4": password,
        }).first()
        if row is None:
            return None
        return models.Account(
            id=row[0],
            tag=row[1],
            account_type=row[2],
            name=row[3],
            email=row[4],
            password=row[5],
            data=row[6],
            created_at=row[7],
            updated_at=row[8],
            deleted_at=row[9],
        )

    def get_tenant(self, *, id: int) -> Optional[models.Tenant]:
        row = self._conn.execute(sqlalchemy.text(GET_TENANT), {"p1": id}).first()
        if row is None:
            return None
        return models.Tenant(
            id=row[0],
            tag=row[1],
            name=row[2],
            description=row[3],
            data=row[4],
            created_at=row[5],
            updated_at=row[6],
            deleted_at=row[7],
        )

    def get_user_by_email(self, *, email: str) -> Optional[models.Account]:
        row = self._conn.execute(sqlalchemy.text(GET_USER_BY_EMAIL), {"p1": email}).first()
        if row is None:
            return None
        return models.Account(
            id=row[0],
            tag=row[1],
            account_type=row[2],
            name=row[3],
            email=row[4],
            password=row[5],
            data=row[6],
            created_at=row[7],
            updated_at=row[8],
            deleted_at=row[9],
        )

    def get_user_by_tag(self, *, tag: uuid.UUID) -> Optional[models.Account]:
        row = self._conn.execute(sqlalchemy.text(GET_USER_BY_TAG), {"p1": tag}).first()
        if row is None:
            return None
        return models.Account(
            id=row[0],
            tag=row[1],
            account_type=row[2],
            name=row[3],
            email=row[4],
            password=row[5],
            data=row[6],
            created_at=row[7],
            updated_at=row[8],
            deleted_at=row[9],
        )

    def list_tenants(self) -> Iterator[models.Tenant]:
        result = self._conn.execute(sqlalchemy.text(LIST_TENANTS))
        for row in result:
            yield models.Tenant(
                id=row[0],
                tag=row[1],
                name=row[2],
                description=row[3],
                data=row[4],
                created_at=row[5],
                updated_at=row[6],
                deleted_at=row[7],
            )

    def update_tenant(self, *, id: int) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_TENANT), {"p1": id})


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_user(self, *, account_type: models.AccountType, name: str, email: str, password: Optional[str]) -> Optional[models.Account]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_USER), {
            "p1": account_type,
            "p2": name,
            "p3": email,
            "p4": password,
        })).first()
        if row is None:
            return None
        return models.Account(
            id=row[0],
            tag=row[1],
            account_type=row[2],
            name=row[3],
            email=row[4],
            password=row[5],
            data=row[6],
            created_at=row[7],
            updated_at=row[8],
            deleted_at=row[9],
        )

    async def get_tenant(self, *, id: int) -> Optional[models.Tenant]:
        row = (await self._conn.execute(sqlalchemy.text(GET_TENANT), {"p1": id})).first()
        if row is None:
            return None
        return models.Tenant(
            id=row[0],
            tag=row[1],
            name=row[2],
            description=row[3],
            data=row[4],
            created_at=row[5],
            updated_at=row[6],
            deleted_at=row[7],
        )

    async def get_user_by_email(self, *, email: str) -> Optional[models.Account]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER_BY_EMAIL), {"p1": email})).first()
        if row is None:
            return None
        return models.Account(
            id=row[0],
            tag=row[1],
            account_type=row[2],
            name=row[3],
            email=row[4],
            password=row[5],
            data=row[6],
            created_at=row[7],
            updated_at=row[8],
            deleted_at=row[9],
        )

    async def get_user_by_tag(self, *, tag: uuid.UUID) -> Optional[models.Account]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER_BY_TAG), {"p1": tag})).first()
        if row is None:
            return None
        return models.Account(
            id=row[0],
            tag=row[1],
            account_type=row[2],
            name=row[3],
            email=row[4],
            password=row[5],
            data=row[6],
            created_at=row[7],
            updated_at=row[8],
            deleted_at=row[9],
        )

    async def list_tenants(self) -> AsyncIterator[models.Tenant]:
        result = await self._conn.stream(sqlalchemy.text(LIST_TENANTS))
        async for row in result:
            yield models.Tenant(
                id=row[0],
                tag=row[1],
                name=row[2],
                description=row[3],
                data=row[4],
                created_at=row[5],
                updated_at=row[6],
                deleted_at=row[7],
            )

    async def update_tenant(self, *, id: int) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_TENANT), {"p1": id})
